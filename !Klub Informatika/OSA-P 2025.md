> [!summary] Skor
> - **Sesi 1:** 10/16
> - **Sesi 2:** 20/24
> - **Sesi 3:** 8/10
> - ***TOTAL:* <u>38/50</u>** (76%)

# Sesi 1

> [!info] Detail
> - **Tipe:** Pilihan ganda.
> - **Jumlah:** 16 soal.
> - **Waktu:** 90 menit.
> - **Penilaian:**
> 	- Benar: +1
> 	- Kosong: 0
> 	- Salah: 0
> - **Skor:** 10/16

> [!important] Pernyataan untuk Nomor 1–3
> Di sebuah pabrik perhiasan, kamu ditugaskan untuk merancang untaian kalung dari manik-manik berwarna putih dan hitam. Persediaan kedua warna ini sangat banyak, jadi kamu tidak perlu khawatir kehabisan bahan.
> 
> Namun, ada dua aturan penting yang wajib dipatuhi dalam merangkai kalung.
> 
> - Tidak boleh ada **$k$ manik hitam berturut-turut** dalam satu kalung.
> - Setiap kalung harus selalu **diawali dengan manik putih**.
> 
> Tugasmu adalah menghitung berapa banyak cara berbeda untuk menyusun kalung dengan panjang $n$ (jumlah total manik), yang memenuhi dua aturan tersebut.


> [!question] Nomor 1 ✅
> Berapakah hasil jika $n = 8$ dan $k = 3$?
> 
> - [ ] 128
> - [x] ***81***
> - [ ] 64
> - [ ] 256
> - [ ] 243

> [!question] Nomor 2
> Berapakah hasil jika $n = 15$ dan $k = 5$?
> 
> - [ ] 13620
> - [ ] 13621
> - [ ] 13622
> - [ ] 13623
> - [x] ***13624***

> [!question] Nomor 3
> Berapakah hasil jika $n = 15$ dan $k = 5$?
> 
> - [x] ***797495860***
> - [ ] 797495861
> - [ ] 797495862
> - [ ] 797495863
> - [ ] 797495864

> [!important] Pernyataan untuk Nomor 4–5
> Pak Dengklek memutuskan untuk merayakan gaji besarnya yang pertama dengan pergi ke restoran.
>
> Dia tinggal di dekat taman yang tidak biasa. Taman tersebut adalah pohon berakar yang terdiri dari $n$ simpul dengan akar di simpul 1. Simpul 1 juga berisi rumah Pak Dengklek. Sayangnya bagi pahlawan kita, taman tersebut juga terdapat anjing. Pak Dengklek sudah mengetahui simpul mana yang memiliki anjing di dalamnya.
>
> Simpul daun dari taman berisi restoran. Pak Dengklek ingin memilih restoran yang akan dia kunjungi, tetapi sayangnya dia sangat takut pada anjing, jadi tidak ada cara dia akan pergi ke restoran jika jalur dari restoran ke rumahnya mengandung lebih dari $m$ simpul berturut-turut dengan anjing.
> 
> Tugas Anda adalah membantu Pak Dengklek menghitung jumlah restoran yang bisa dia kunjungi.

> [!question] Nomor 4
> Jika taman membentuk suatu *binary tree* sempurna dengan total 1023 simpul (termasuk rumah Pak Dengklek), ada berapa banyak restoran yang tersedia?
> 
> - [ ] 256
> - [ ] 258
> - [x] ***512***
> - [ ] 128
> - [ ] 126

> [!question] Nomor 5
> Jika taman membentuk suatu line graph (1)—(2)—(3)—(4) dan seterusnya. Taman tersebut diketahui terdapat 1000 simpul. Jika setiap bilangan dengan jumlah faktor genap terdapat anjing. Berapa nilai $m$ minimum agar Pak Dengklek dapat mengunjungi minimal 1 restoran?
> 
> - [ ] *63*
> - [ ] 62
> - [ ] 61
> - [x] **60**
> - [ ] 59

> [!important] Pernyataan untuk Nomor 6–7
> Pada OSN-P 2025 setiap peserta diberikan masing-masing sebanyak $n$ koin emas sebagai suatu tantangannya. Diketahui, dari $n$ koin emas tersebut terdapat 1 koin yang palsu. Koin palsu tersebut memiliki massa yang lebih ringan dibandingkan koin emas yang asli. Masing-masing peserta diberikan suatu neraca timbangan untuk mengecek manakah emas yang palsu. Pelatos sebagai salah satu murid unggulan tentunya mengerjakan tantangan tersebut dengan langkah paling optimal.

> [!question] Nomor 6
> Jika $n = 512$, berapa banyak penimbangan paling sedikit untuk mengetahui koin mana yang palsu?
> 
> - [ ] 511
> - [ ] 256
> - [ ] *9*
> - [x] **6**
> - [ ] 3

> [!question] Nomor 7
> Jika $n = 4096$, berapa banyak penimbangan paling sedikit untuk mengetahui koin mana yang palsu?
> 
> - [ ] 4095
> - [ ] 2048
> - [ ] *12*
> - [ ] 11
> - [x] **9**

> [!question] Nomor 8
> Pak Pelatos memiliki hobi dalam melukis. Pak Pelatos memiliki 3 buah palet yang menjadi kesayangannya. Palet pertama memiliki 3 warna, yaitu merah, biru, dan hijau. Palet kedua memiliki 4 warna, yaitu kuning, hijau, jingga, dan merah. Palet terakhir memiliki 5 warna, yaitu merah, biru, kuning, hijau, dan ungu.
> 
> Pak Pelatos juga memiliki 5 buah kanvas yang belum memiliki warna pada awalnya. Berapa banyak konfigurasi warna pada kanvas jika Pak Pelatos memilih warna dari kanvas yang ia miliki dan Pak Pelatos hanya dapat memilih warna dari palet yang sama (jika kanvas 1 dari palet 1 maka kanvas 2–5 harus juga dari palet 1)?
> 
> - [x] ***3906***
> - [ ] 6930
> - [ ] 9036
> - [ ] 6039
> - [ ] 3690

> [!question] Nomor 9
> Pelatos tersesat pada labirin yang menggunakan koordinat cartesius. Kebetulan, Pelatos sekarang berada pada titik $(0, 0)$ dan hanya dapat bergerak ke atas dan ke kanan. Hitunglah berapa banyak cara untuk mencapai titik $(5, 5)$ dari titik awal Pelatos?
> 
> - [x] ***252***
> - [ ] 504
> - [ ] 126
> - [ ] 1080
> - [ ] 2160

> [!question] Nomor 10
> Setelah menebak angka, sekarang peserta perlu menghitung berapa banyak kemungkinan untuk mengisi suatu lantai berukuran 1x15. Lantai dapat diisi dengan ubin-ubin berukuran 1x1, 1x2, dan 1x4.
> 
> - [ ] 2890
> - [x] ***2809***
> - [ ] 3430
> - [ ] 3403
> - [ ] 1024

> [!question] Nomor 11
> Berapakah banyak 0 di belakang 4045 faktorial?
> 
> - [x] ***1009***
> - [ ] 1010
> - [ ] 1011
> - [ ] 1012
> - [ ] 1008

> [!question] Nomor 12
> Evan membutuhkan pencahayaan yang maksimal untuk belajarnya, diketahui iya memerlukan semua lampu untuk menyala agar belajar yang ia lakukan maksimal. Namun, saklar di rumahnya sedikit unik dimana jika suatu saklar dipencet, akan berpengaruh tidak hanya pada saklar tersebut saja tapi juga untuk semua saklar dengan angka lebih besar dari yang diubah tersebut. Hitunglah berapa operasi minimum yang perlu dilakukan jika pada awalnya kondisi lampu seperti berikut!
> 
> ![[OSA-P 2025 Sesi 1 Nomor 12.png]]
> 
> - [ ] 13
> - [ ] 12
> - [ ] 11
> - [ ] 10
> - [x] ***9***

> [!question] Nomor 13
> Setiap Pelatos diberikan 10 pasang tanda kurung `()`. Diketahui bahwa tanda-tanda kurung tersebut disusun secara bebas asalkan setiap `)` harus didahului oleh tanda `(`. Contoh susunan yang valid adalah `()()` dan `(())`. Sedangkan `)(()` dan `)()(` merupakan susunan yang tidak valid. Dari informasi yang beredar, setiap Pelatos menyusun tanda-tanda kurung tersebut dengan susunan yang berbeda. Berapa pelatos maksimal yang ikut berpartisipasi?
> 
> - [ ] *15796*
> - [ ] 16786
> - [x] **16796**
> - [ ] 19576
> - [ ] 17956

> [!question] Nomor 14
> Terdapat 2025 orang dengan pernyataan yang berbeda-beda.
> 
> - Orang pertama berkata 1 orang berkata bohong.
> - Orang kedua berkata 2 orang berkata bohong.
> - ⋮
> - Orang ke-2025 berkata 2025 orang berkata bohong.
> 
> Orang keberapa yang dipastikan jujur?
> 
> - [ ] 1013
> - [ ] 1012
> - [ ] 2025
> - [x] **2024**
> - [ ] *1*

> [!question] Nomor 15
> Dari 100000 buah bilangan bulat positif pertama, berapa banyak bilangan yang mengandung tepat 1 buah angka 2, 1 buah angka 4, dan 1 buah angka 6?
> 
> - [ ] 2490
> - [x] **2940**
> - [ ] 4920
> - [ ] 4290
> - [ ] 9420

> [!question] Nomor 16
> Berapakah penjumlahan dari 2 digit terakhir penjumlahan berikut?
> $$1! + 2! + 3! + \cdots + 2023! + 2024!$$
> 
> - [ ] 8
> - [ ] 12
> - [x] ***4***
> - [ ] 6
> - [ ] 10

---

# Sesi 2

> [!info] Detail
> - **Tipe:** Benar/salah.
> - **Jumlah:** 5 soal, 4 subsoal per soal.
> - **Waktu:** 30 menit.
> - **Penilaian:**
> 	- Benar: +1
> 	- Kosong: 0
> 	- Salah: 0
> - **Skor:** 16/20 (80%)

- ✓: Jawaban terpilih.
- ✅: Jawaban sebenarnya.

> [!question] Nomor 1
> Pak Dengklek menyukai angka keberuntungan. Semua orang tahu bahwa angka keberuntungan adalah bilangan bulat positif yang representasi desimalnya hanya mengandung digit keberuntungan 4 dan 7. Sebagai contoh, angka 47, 744, dam 4 adalah angka keberuntungan. Tetapi 5, 17, dan 467 bukan.
> 
> Pak Dengklek menyebut sebuah angka hampir beruntung jika dapat dibagi habis oleh beberapa angka keberuntungan. Bantu dia untuk menentukan apakah angka $n$ yang diberikan beruntung atau hampir beruntung di mana $n \leq 1000$.
> 
> |   B    |   S    | Pernyataan                                            |
> | :----: | :----: | ----------------------------------------------------- |
> |        | ✓<br>✅ | 777 adalah angka beruntung/hampir beruntung terbesar. |
> | ✓<br>✅ |        | Terdapat tepat 2 bilangan prima yang beruntung.       |
> |        | ✓<br>✅ | Terdapat tepat 3 bilangan prima yang beruntung.       |
> | ✓<br>✅ |        | 987 adalah bilangan beruntung/hampir beruntung.       |

> [!question] Nomor 2
> Seorang insinyur robotik sedang merancang robot eksplorasi untuk menjelajah labirin persegi berukuran $n \times n$. Robot memulai dari pojok kiri atas $(0, 0)$ dan harus mencapai pojok kanan bawah $(n − 1, n − 1)$. Robot hanya dapat bergerak ke kanan atau ke bawah. Beberapa petak merupakan dinding dan tidak bisa dilewati. Labirin diberikan dalam bentuk peta grid.
> 
> |   B    |   S    | Pernyataan                                                                                                                                                           |
> | :----: | :----: | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
> | <br>✅  |   ✓    | Jika tidak ada dinding, maka jumlah jalur berbeda yang dapat diambil oleh robot dari $(0, 0)$ ke $(n - 1, n - 1)$ adalah $\binom{2n - 2}{n - 1}$.                    |
> |        | ✓<br>✅ | Menambahkan satu petak dinding di tengah dapat mengurangi jumlah jalur tepat satu.                                                                                   |
> | ✓<br>✅ |        | Algoritma pencarian seperti *depth-first search* atau *backtracking* dapat digunakan untuk menghitung jumlah semua jalur valid.                                      |
> | ✓<br>✅ |        | Jumlah jalur dari kiri atas ke kanan bawah dapat dihitung menggunakan metode *dynamic programming* dengan kompleksitas waktu $O(n^2)$ jika semua sel bebas hambatan. |

> [!question] Nomor 3
> Permainan Menara Hanoi biasanya dimainkan dengan 3 tiang. Namun, seorang peneliti tertarik pada versi dengan 4 tiang, di mana cakram harus dipindahkan dari tiang pertama ke tiang keempat dengan aturan yang sama: satu cakram dipindahkan dalam satu waktu, dan cakram lebih besar tidak boleh diletakkan di atas cakram lebih kecil.
> 
> |   B    |   S    | Pernyataan                                                                                                  |
> | :----: | :----: | ----------------------------------------------------------------------------------------------------------- |
> |        | ✓<br>✅ | Untuk 4 tiang, sudah ada rumus pasti untuk langkah minimum secara umum.                                     |
> | ✓<br>✅ |        | Untuk tiga tiang, jumlah minimum langkah yang diperlukan adalah $2^n - 1$ di mana $n$ adalah banyak cakram. |
> | ✓<br>✅ |        | Penambahan tiang dapat menurunkan jumlah langkah minimum.                                                   |
> | ✓<br>✅ |        | Algoritma berbasis *dynamic programming* digunakan dalam mencari solusi optimal dengan 4 tiang.             |

> [!question] Nomor 4
> Suatu wilayah terdiri dari $n$ kota yang ingin dihubungkan dengan jaringan transmisi energi. Setiap jaringan (kabel) memiliki biaya pemasangan. Pemerintah ingin menghemat biaya dengan hanya memasang jaringan sesedikit mungkin, tetapi tetap menjamin bahwa semua kota bisa saling terhubung (langsung atau tak langsung).
> 
> Untuk efisiensi distribusi energi, ada pula bobot keandalan pada tiap kabel, yang menunjukkan seberapa andal kabel itu dalam kondisi ekstrem (misalnya badai). Pemerintah ingin memilih jaringan transmisi yang
> 
> - menghubungkan semua kota;
> - memiliki biaya total minimum; serta
> - di antara semua jaringan dengan biaya minimum, pemerintah ingin memilih yang paling andal, yaitu jumlah total bobot keandalan paling tinggi.
> 
> Jaringan direpresentasikan sebagai graf tak berarah berbobot ganda. Setiap sisi memiliki bobot biaya dan keandalan.
> 
> |   B    |   S    | Pernyataan                                                                                                                                     |
> | :----: | :----: | ---------------------------------------------------------------------------------------------------------------------------------------------- |
> | ✓<br>✅ |        | Algoritma Kruskal dengan prioritas utama pada bobot biaya dapat digunakan untuk mencari solusi awal berupa *minimum spanning tree*.            |
> | ✓<br>✅ |        | Jika terdapat lebih dari satu *minimum spanning tree* dengan biaya total yang sama, maka kita dapat memilih berdasarkan bobot keandalan.       |
> |        | ✓<br>✅ | Algoritma Djikstra lebih cocok untuk menyelesaikan masalah ini karena mempertimbangkan bobot dan jalur terpendek.                              |
> | ✓<br>✅ |        | Struktur data *disjoint set union* sangat berguna untuk mendeteksi siklus saat membangun *minimum spanning tree* menggunakan Algoritma Kruskal |

> [!question] Nomor 5
> Sebuah pusat distribusi di kota Metrix menggunakan sistem penataan otomatis untuk mengurutkan kontainer sebelum dikirim ke pelanggan. Setiap kontainer memiliki nomor unik dari 1 hingga $n$, dan seluruh kontainer awalnya tersusun dalam urutan acak di sepanjang lintasan konveyor.
> 
> Sistem hanya dapat melakukan pertukaran dua kontainer bersebelahan sekaligus dalam satu langkah. Tujuan sistem adalah menata ulang kontainer sehingga nomornya tersusun secara menaik, dari 1 sampai $n$, dengan jumlah pertukaran minimum.
> 
> Karena keterbatasan waktu proses, teknisi sistem ingin menghitung seberapa cepat sistem bisa menyelesaikan tugas tersebut, dan sedang mempertimbangkan berbagai pendekatan algoritmis serta analisis teoritis.
> 
> |   B    |   S    | Pernyataan                                                                                     |
> | :----: | :----: | ---------------------------------------------------------------------------------------------- |
> | ✓<br>✅ |        | Fenwick Tree dan Segment Tree bisa digunakan untuk menghitung jumlah *inversion* pada *array*. |
> | <br>✅  |   ✓    | Jumlah pertukaran minimum yang dilakukan sama dengan jumlah *inversion* pada *array*.          |
> |   ✓    | <br>✅  | Algoritma *bubble sort* yang dilakukan memiliki kompleksitas terburuk $O(n \log n)$.           |
> |        | ✓<br>✅ | Jumlah pertukaran maksimal adalah $n^2$.                                                       |

> [!question] Soal 6
> Sebuah perusahaan ekspedisi di kota Techvalley sedang mengembangkan sistem pengambilan keputusan otomatis untuk menentukan barang mana saja yang harus dimasukkan ke dalam satu kendaraan pengantar.
> 
> Terdapat $n$ buah barang, masing-masing dengan berat dan nilai ekonomi berbeda. Setiap kendaraan memiliki kapasitas maksimum $W$ (dalam satuan berat). Tujuan sistem adalah memilih kombinasi barang yang memaksimalkan nilai total tanpa melebihi kapasitas kendaraan.
> 
> Karena ribuan pengambilan keputusan ini harus dilakukan setiap jam, insinyur perusahaan ingin tahu apakah strategi *greedy* cukup baik, atau apakah harus menggunakan algoritma dinamis yang lebih kompleks.
> 
> |   B    |   S    | Pernyataan                                                                                                                                                    |
> | :----: | :----: | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
> | ✓<br>✅ |        | Penyelesaian terbaik untuk *knapsack* adalah *dynamic programming*.                                                                                           |
> |        | ✓<br>✅ | Strategi *greedy* berdasarkan rasio nilai/berat selalu memberikan solusi optimal untuk *knapsack*.                                                            |
> | <br>✅  |   ✓    | Kompleksitas waktu dari solusi *dynamic programming* konvensional adalah $O(n \times W)$, di mana $n$ adalah banyak barang dan $W$ adalah kapasitas maksimum. |
> | ✓<br>✅ |        | Jika seluruh berat barang kelipatan bilangan tetap (misalnya 5), maka kita bisa melakukan kompresi state untuk menghemat memori dalam *dynamic programming*.  |

---

# Sesi 3

> [!info] Detail
> - **Tipe:** Pilihan ganda.
> - **Jumlah:** 10 soal.
> - **Waktu:** 60 menit.
> - **Penilaian:**
> 	- Benar: +1
> 	- Kosong: 0
> 	- Salah: 0
> - **Skor:** 10/15 (66.67%)

> [!important] Pernyataan untuk Nomor 1–3
> Perhatikan potongan kode berikut.
> 
> ```cpp
> long long air(long long api, long long panas) {
> 	if (api == 0 || panas == 0) {
> 		return 1;
> 	}
> 
> 	return air(api - 1, panas) + air(api, panas - 1);
> }
> ```

> [!question] Nomor 1
> Tentukan keluaran dari `air(3, 3)`.
> 
> - [x] ***20***
> - [ ] 6
> - [ ] 12
> - [ ] 30
> - [ ] 18

> [!question] Nomor 2
> Tentukan keluaran dari `air(6, 8)`.
> 
> - [ ] 1001
> - [ ] 2002
> - [x] ***3003***
> - [ ] 4004
> - [ ] 5005

> [!question] Nomor 3
> Tentukan keluaran dari `air(9, 5)`.
> 
> - [ ] 1001
> - [ ] *2002*
> - [ ] 3003
> - [ ] 4004
> - [x] **5005**

> [!question] Nomor 4
> Pak Dengklek sedang berlatih mengerjakan soal *binary search* klasik karena ia akan mengikuti OSN-P 2040. Berikut adalah program yang ia buat.
> 
> ```cpp
> #include <bits/stdc++.h>
> using namespace std;
> 
> int main()
> {
> 	int N;
> 	cin >> N;
> 
> 	int arr[N + 1];
> 	for (int i = 1; i <= N; i++)
> 		cin >> arr[i];
> 
> 	int cari;
> 	cin >> cari;
> 
> 	int kiri = 1;
> 	int kanan = N;
> 	
> 	bool ketemu = false;
> 
> 	while (kiri <= kanan) {
> 		int tengah = (kiri + kanan) / 2;
> 
> 		if (arr[tengah] == cari) {
> 			ketemu = true;
> 			break;
> 		} else if (arr[tengah] < cari) {
> 			kiri = tengah + 1;
> 		} else {
> 			kanan = tengah - 1;
> 		}
> 	}
> 
> 	if (ketemu == false)
> 		cout << "Tidak ada\n";
> 	else
> 		cout << "Ada\n";
> }
> ```
> 
> Namun program yang ia buat sering membuat kesalahan output. Program tersebut bisa mengoutput `Tidak ada` saat bilangan yang dicari sebenarnya ada dalam barisan tersebut. Baris apa yang seharusnya ditambahkan Pak Dengklek?
> 
> - [ ] `sort(arr, arr+N);`
> - [x] ***`sort(arr+1, arr+N+1);`***
> - [ ] `sort(arr, arr+N, greater<int>());`
> - [ ] `sort(arr+1, arr+N+1, greater<int>());`
> - [ ] Tidak ada yang perlu ditambah, tetapi ada baris yang kurang tepat

> [!question] Nomor 5
> Pak Dengklek sedang membuat program untuk mencari banyaknya pasangan $(i, j)$ dengan $0 \leq i < j < N$ di mana $A_i \times A_j = A_i \mathbin{\text{or}} A_j$. Berikut adalah perintah program yang ia buat.
> 
> ```cpp
> #include <bits/stdc++.h>
> using namespace std;
> 
> int main()
> {
> 	int N;
> 	cin >> N;
> 
> 	int A[N];
> 	for (int i = 0; i < N; i++)
> 		cin >> A[i];
> 
> 	long long ans = 0;
> 	for (int i = 0; i < N; i++) {
> 		for (int j = i + 1; j < N; j++) {
> 			if (A[i] * A[j] == A[i] | A[j]) {
> 				ans++;
> 			}
> 		}
> 	}
> 
> 	cout << ans << endl;
> 	return 0;
> }
> ```
> 
> Namun, ketika ia mencoba untuk menjalan program tersebut, ia mendapatkan hasil yang tidak sesuai dengan jawaban yang sesungguhnya. Bantu Pak Dengklek untuk menentukan pada baris keberapa Pak Dengklek perlu memperbaiki programnya!
> - [ ] 14
> - [ ] 15
> - [x] ***16***
> - [ ] 17
> - [ ] Tidak ada yang perlu diperbaiki

> [!question] Nomor 6
> Hewan-hewan di hutan baru saja belajar bagaimana cara *coding* menggunakan C++. Bersama-sama mereka membuat dua buah fungsi seperti berikut.
> 
> ```cpp
> long long kucing(long long sapi, long long kerbau, long long beruang)
> {
> 	while (sapi >= beruang)
> 		sapi -= beruang;
> 
> 	for (int i = 0; i < (kerbau / beruang); i++)
> 		kerbau = kerbau - beruang;
> 
> 	return (sapi * kerbau) % beruang;
> }
> 
> long long cantik(long long kuda, long long nil, long long berenang)
> {
> 	if (nil == 0)
> 		return 1;
> 
> 	long long suka = cantik(kuda, nil >> 1, berenang);
> 	suka = kucing(suka, suka, berenang);
> 
> 	if (nil & 1)
> 		return kucing(suka, kuda, berenang);
> 
> 	return suka;
> }
> ```
> 
> Singa Sang Raja Hutan pusing membaca program mereka, ia hanya ingin tahu berapa nilai keluaran dari `cantik(5, 7, 30)`. Dapatkah Anda membantu sang singa untuk menemukan jawabannya?
> 
> - [ ] 0
> - [x] ***5***
> - [ ] 15
> - [ ] 25
> - [ ] Tidak ada keluaran

> [!question] Nomor 7
> Perhatikan potongan program berikut ini.
> 
> ```cpp
> #include <bits/stdc++.h>
> using namespace std;
> 
> int main()
> {
> 	int babi, sapi;
> 	std::cin >> babi >> sapi;
> 	
> 	while (babi != sapi) {
> 		if (babi > sapi) {
> 			int kuda = babi;
> 			babi = sapi;
> 			sapi = kuda;
> 		}
> 	
> 		sapi -= babi;
> 	}
> 	
> 	std::cout << babi << std::endl;
> }
> ```
> 
> Berapakah keluaran jika masukannya adalah `17266 60431`?
> 
> - [ ] 1
> - [ ] 89
> - [ ] 97
> - [x] ***8633***
> - [ ] Program tidak akan berakhir

> [!question] Nomor 8
> Evan sedang membuat program untuk menghitung kombinasi. Berikut adalah potongan program yang telah ia buat.
> 
> ```cpp
> const int LIM = 1e6;
> const int MOD = 1e9 + 7;
> 
> long long fact[LIM + 5], invfact[LIM + 5];
> 
> long long multiply(long long A, long long B)
> {
> 	return ((A % MOD) * (B % MOD)) % MOD;
> }
> 
> long long modex(long long base, long long pow)
> {
> 	if (pow == 0)
> 		return 1;
> 	if (pow == 1)
> 		return base % MOD;
> 	
> 	long long res = modex(base, pow / 2);
> 	
> 	res = multiply(res, res);
> 	if(pow & 1) res = multiply(res, base);
> 	
> 	return res;
> }
> 
> long long inv(long long x)
> {
> 	return modex(x , MOD - 2);
> }
> 
> void pre_compute()
> {
> 	fact[0] = 1;
> 	
> 	for (int i = 1; i <= LIM; i++) {
> 		fact[i] = multiply(fact[i - 1], i);
> 	}
> 	
> 	for (int i = 1; i <= LIM; i++) {
> 		invfact[i] = inv(fact[i]);
> 	}
> }
> 
> long long combinaton(long long n, long long r)
> {
> 	long long penyebut = multiply(invfact[r], invfact[n - r]);
> 	return multiply(fact[n], penyebut);
> }
> ```
> 
> Namun, ketika Evan mencoba menggunakan fungsi `combination(977, 977)`, ia mendapatkan keluaran `0`, seharusnya $\binom{977}{977} = 1$. Bantulah Evan untuk menentukan baris berapa yang menjadi sumber bug!
> 
> - [ ] 4
> - [ ] 21
> - [ ] *28*
> - [x] **39**
> - [ ] 46

> [!important] Pernyataan untuk Nomor 9–10
> Perhatikan potongan kode berikut.
> ```cpp
> long long mod = 1e9 + 7;
> 
> long long f(long long b, long long e) {
> 	long long res = 1;
> 
> 	while (e > 0) {
> 		if (e & 1)
> 			res *= b;
> 		res %= mod;
> 		b *= b;
> 		b %= mod;
> 		e = e >> 1;
> 	}
> 
> 	return res;
> }
> ```

> [!question] Nomor 9
> Berapakah hasil pemanggilan `f(2, 10)`?
> 
> - [ ] 2048
> - [x] ***1024***
> - [ ] 512
> - [ ] 256

> [!question] Nomor 10
> Berapakah hasil pemanggilan `f(2, 29)`?
> 
> - [x] ***536870912***
> - [ ] 53679012
> - [ ] 53679102
> - [ ] 50367912