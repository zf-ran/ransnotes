# Sesi 1

> [!info] Detail
> - **Tipe:** Pilihan ganda.
> - **Jumlah:** 16 soal.
> - **Waktu:** 90 menit.
> - **Penilaian:**
> 	- Benar: +1
> 	- Kosong: 0
> 	- Salah: 0
> - **Skor:** 10/15 (66.67%)

> [!important] *Pernyataan* untuk Nomor 1–3
> Di sebuah pabrik perhiasan, kamu ditugaskan untuk merancang untaian kalung dari manik-manik berwarna putih dan hitam. Persediaan kedua warna ini sangat banyak, jadi kamu tidak perlu khawatir kehabisan bahan.
> 
> Namun, ada dua aturan penting yang wajib dipatuhi dalam merangkai kalung.
> 
> - Tidak boleh ada **$k$ manik hitam berturut-turut** dalam satu kalung.
> - Setiap kalung harus selalu **diawali dengan manik putih**.
> 
> Tugasmu adalah menghitung berapa banyak cara berbeda untuk menyusun kalung dengan panjang $n$ (jumlah total manik), yang memenuhi dua aturan tersebut.


> [!question] Nomor 1
> Berapakah hasil jika $n = 8$ dan $k = 3$?
> 
> - [ ] 128
> - [x] ***81***
> - [ ] 64
> - [ ] 256
> - [ ] 243

> [!question] Nomor 2
> Berapakah hasil jika $n = 15$ dan $k = 5$?
> 
> - [ ] 13620
> - [ ] 13621
> - [ ] 13622
> - [ ] 13623
> - [x] ***13624***

> [!question] Nomor 3
> Berapakah hasil jika $n = 15$ dan $k = 5$?
> 
> - [x] ***797495860***
> - [ ] 797495861
> - [ ] 797495862
> - [ ] 797495863
> - [ ] 797495864

> [!important] Pernyataan untuk Nomor 4–5
> Pak Dengklek memutuskan untuk merayakan gaji besarnya yang pertama dengan pergi ke restoran.
>
> Dia tinggal di dekat taman yang tidak biasa. Taman tersebut adalah pohon berakar yang terdiri dari $n$ simpul dengan akar di simpul 1. Simpul 1 juga berisi rumah Pak Dengklek. Sayangnya bagi pahlawan kita, taman tersebut juga terdapat anjing. Pak Dengklek sudah mengetahui simpul mana yang memiliki anjing di dalamnya.
>
> Simpul daun dari taman berisi restoran. Pak Dengklek ingin memilih restoran yang akan dia kunjungi, tetapi sayangnya dia sangat takut pada anjing, jadi tidak ada cara dia akan pergi ke restoran jika jalur dari restoran ke rumahnya mengandung lebih dari $m$ simpul berturut-turut dengan anjing.
> 
> Tugas Anda adalah membantu Pak Dengklek menghitung jumlah restoran yang bisa dia kunjungi.

> [!question] Nomor 4
> Jika taman membentuk suatu *binary tree* sempurna dengan total 1023 simpul (termasuk rumah Pak Dengklek), ada berapa banyak restoran yang tersedia?
> 
> - [ ] 256
> - [ ] 258
> - [x] ***512***
> - [ ] 128
> - [ ] 126

> [!question] Nomor 5
> Jika taman membentuk suatu line graph (1)—(2)—(3)—(4) dan seterusnya. Taman tersebut diketahui terdapat 1000 simpul. Jika setiap bilangan dengan jumlah faktor genap terdapat anjing. Berapa nilai $m$ minimum agar Pak Dengklek dapat mengunjungi minimal 1 restoran?
> 
> - [ ] *63*
> - [ ] 62
> - [ ] 61
> - [x] **60**
> - [ ] 59

> [!important] Pernyataan untuk Nomor 6–7
> Pada OSN-P 2025 setiap peserta diberikan masing-masing sebanyak $n$ koin emas sebagai suatu tantangannya. Diketahui, dari $n$ koin emas tersebut terdapat 1 koin yang palsu. Koin palsu tersebut memiliki massa yang lebih ringan dibandingkan koin emas yang asli. Masing-masing peserta diberikan suatu neraca timbangan untuk mengecek manakah emas yang palsu. Pelatos sebagai salah satu murid unggulan tentunya mengerjakan tantangan tersebut dengan langkah paling optimal.

> [!question] Nomor 6
> Jika $n = 512$, berapa banyak penimbangan paling sedikit untuk mengetahui koin mana yang palsu?
> 
> - [ ] 511
> - [ ] 256
> - [ ] *9*
> - [x] **6**
> - [ ] 3

> [!question] Nomor 7
> Jika $n = 4096$, berapa banyak penimbangan paling sedikit untuk mengetahui koin mana yang palsu?
> 
> - [ ] 4095
> - [ ] 2048
> - [ ] *12*
> - [ ] 11
> - [x] **9**

> [!question] Nomor 8
> Pak Pelatos memiliki hobi dalam melukis. Pak Pelatos memiliki 3 buah palet yang menjadi kesayangannya. Palet pertama memiliki 3 warna, yaitu merah, biru, dan hijau. Palet kedua memiliki 4 warna, yaitu kuning, hijau, jingga, dan merah. Palet terakhir memiliki 5 warna, yaitu merah, biru, kuning, hijau, dan ungu.
> 
> Pak Pelatos juga memiliki 5 buah kanvas yang belum memiliki warna pada awalnya. Berapa banyak konfigurasi warna pada kanvas jika Pak Pelatos memilih warna dari kanvas yang ia miliki dan Pak Pelatos hanya dapat memilih warna dari palet yang sama (jika kanvas 1 dari palet 1 maka kanvas 2–5 harus juga dari palet 1)?
> 
> - [x] ***3906***
> - [ ] 6930
> - [ ] 9036
> - [ ] 6039
> - [ ] 3690

> [!question] Nomor 9
> Pelatos tersesat pada labirin yang menggunakan koordinat cartesius. Kebetulan, Pelatos sekarang berada pada titik $(0, 0)$ dan hanya dapat bergerak ke atas dan ke kanan. Hitunglah berapa banyak cara untuk mencapai titik $(5, 5)$ dari titik awal Pelatos?
> 
> - [x] ***252***
> - [ ] 504
> - [ ] 126
> - [ ] 1080
> - [ ] 2160

> [!question] Nomor 10
> Setelah menebak angka, sekarang peserta perlu menghitung berapa banyak kemungkinan untuk mengisi suatu lantai berukuran 1x15. Lantai dapat diisi dengan ubin-ubin berukuran 1x1, 1x2, dan 1x4.
> 
> - [ ] 2890
> - [x] ***2809***
> - [ ] 3430
> - [ ] 3403
> - [ ] 1024

> [!question] Nomor 11
> Berapakah banyak 0 pada akhiran 4045 faktorial?
> 
> - [x] ***1009***
> - [ ] 1010
> - [ ] 1011
> - [ ] 1012
> - [ ] 1008

> [!question] Nomor 12
> Evan membutuhkan pencahayaan yang maksimal untuk belajarnya, diketahui iya memerlukan semua lampu untuk menyala agar belajar yang ia lakukan maksimal. Namun, saklar di rumahnya sedikit unik dimana jika suatu saklar dipencet, akan berpengaruh tidak hanya pada saklar tersebut saja tapi juga untuk semua saklar dengan angka lebih besar dari yang diubah tersebut. Hitunglah berapa operasi minimum yang perlu dilakukan jika pada awalnya kondisi lampu seperti berikut!
> 
> ![[OSA-P 2025 Sesi 1 Nomor 12.png]]
> 
> - [ ] 13
> - [ ] 12
> - [ ] 11
> - [ ] 10
> - [x] ***9***

> [!question] Nomor 13
> Setiap Pelatos diberikan 10 pasang tanda kurung `()`. Diketahui bahwa tanda-tanda kurung tersebut disusun secara bebas asalkan setiap `)` harus didahului oleh tanda `(`. Contoh susunan yang valid adalah `()()` dan `(())`. Sedangkan `)(()` dan `)()(` merupakan susunan yang tidak valid. Dari informasi yang beredar, setiap Pelatos menyusun tanda-tanda kurung tersebut dengan susunan yang berbeda. Berapa pelatos maksimal yang ikut berpartisipasi?
> 
> - [ ] *15796*
> - [ ] 16786
> - [x] **16796**
> - [ ] 19576
> - [ ] 17956

> [!question] Nomor 14
> Terdapat 2025 orang dengan pernyataan yang berbeda-beda.
> 
> - Orang pertama berkata 1 orang berkata bohong.
> - Orang kedua berkata 2 orang berkata bohong.
> - ⋮
> - Orang ke-2025 berkata 2025 orang berkata bohong.
> 
> Orang keberapa yang dipastikan jujur?
> 
> - [ ] 1013
> - [ ] 1012
> - [ ] 2025
> - [x] **2024**
> - [ ] *1*

> [!question] Nomor 15
> Dari 100000 buah bilangan bulat positif pertama, berapa banyak bilangan yang mengandung tepat 1 buah angka 2, 1 buah angka 4, dan 1 buah angka 6?
> 
> - [ ] 2490
> - [x] **2940**
> - [ ] 4920
> - [ ] 4290
> - [ ] 9420

> [!question] Nomor 16
> Berapakah penjumlahan dari 2 digit terakhir penjumlahan berikut?
> $$1! + 2! + 3! + \cdots + 2023! + 2024!$$
> 
> - [ ] 8
> - [ ] 12
> - [x] ***4***
> - [ ] 6
> - [ ] 10

---

# Sesi 2

> [!info] Detail
> - **Tipe:** Benar/salah.
> - **Jumlah:** 5 soal, 4 subsoal per soal.
> - **Waktu:** 30 menit.
> - **Penilaian:**
> 	- Benar: +1
> 	- Kosong: 0
> 	- Salah: 0
> - **Skor:** 17/20 (85%)

- 1
	- SBSB (SBSB)
- 2
	- BSBB (SSBB)
- 3
	- SBBB (SBBB)
- 4
	- BBSB (BBSB)
- 5
	- BBSS (BSBS)

Soal 1

Pak Dengklek menyukai angka keberuntungan. Semua orang tahu bahwa angka keberuntungan adalah bilangan bulat positif yang representasi desimalnya hanya mengandung digit keberuntungan 4 dan 7. Sebagai contoh, angka 47, 744, 4 adalah angka keberuntungan dan 5, 17, 467 bukan.

Pak Dengklek menyebut sebuah angka hampir beruntung jika dapat dibagi habis oleh beberapa angka keberuntungan. Bantu dia untuk menentukan apakah angka yang diberikan n hampir beruntung. (n<=1000)
Benar 	Salah 	Pernyataan
		

777 adalah n terbesar yang beruntung/hampir beruntung
		

Terdapat tepat 2 bilangan prima yang beruntung
		

Terdapat tepat 3 bilangan prima yang beruntung
		

987 adalah bilangan beruntung/hampir beruntung

Soal 2

Seorang insinyur robotika sedang merancang robot eksplorasi untuk menjelajah labirin persegi berukuran n×nn \times nn×n. Robot memulai dari pojok kiri atas (0,0) dan harus mencapai pojok kanan bawah (n−1,n−1). Robot hanya dapat bergerak ke kanan atau ke bawah. Beberapa petak merupakan dinding dan tidak bisa dilewati. Labirin diberikan dalam bentuk peta grid.
Benar 	Salah 	Pernyataan
		

Jika tidak ada dinding, maka jumlah jalur berbeda yang dapat diambil oleh robot dari (0,0) ke (n−1,n−1) adalah C(2n-2, n-1)
		

Menambahkan satu petak dinding di tengah dapat mengurangi jumlah jalur tepat satu
		

Algoritma pencarian seperti DFS atau backtracking dapat digunakan untuk menghitung jumlah semua jalur valid
		

Jumlah jalur dari kiri atas ke kanan bawah dapat dihitung menggunakan metode dynamic programming dengan kompleksitas waktu O(n²) jika semua sel bebas hambatan.

Soal 3

Permainan Menara Hanoi biasanya dimainkan dengan 3 tiang. Namun, seorang peneliti tertarik pada versi dengan 4 tiang, di mana cakram harus dipindahkan dari tiang pertama ke tiang keempat dengan aturan yang sama: satu cakram dipindahkan dalam satu waktu, dan cakram lebih besar tidak boleh diletakkan di atas cakram lebih kecil.
Benar 	Salah 	Pernyataan
		

Untuk 4 tiang, sudah ada rumus pasti untuk langkah minimum secara umum
		

Untuk 3 tiang, jumlah minimum langkah yang diperlukan adalah 2n-1
		

Penambahan tiang dapat menurunkan jumlah langkah minimum
		

Algoritma berbasis dynamic programming digunakan dalam mencari solusi optimal dengan 4 tiang

Soal 4

Suatu wilayah terdiri dari n kota yang ingin dihubungkan dengan jaringan transmisi energi. Setiap jaringan (kabel) memiliki biaya pemasangan. Pemerintah ingin menghemat biaya dengan hanya memasang jaringan seminimal mungkin, tetapi tetap menjamin bahwa semua kota bisa saling terhubung (langsung atau tak langsung).

Untuk efisiensi distribusi energi, ada pula bobot keandalan pada tiap kabel, yang menunjukkan seberapa andal kabel itu dalam kondisi ekstrem (misalnya badai). Pemerintah ingin memilih jaringan transmisi yang:

-Menghubungkan semua kota.

-Memiliki biaya total minimum.

-Di antara semua jaringan dengan biaya minimum, pemerintah ingin memilih yang paling andal, yaitu jumlah total bobot keandalan paling tinggi.

Jaringan direpresentasikan sebagai graf tak berarah berbobot ganda: setiap sisi memiliki bobot biaya dan keandalan.
Benar 	Salah 	Pernyataan
		

Algoritma Kruskal dengan prioritas utama pada bobot biaya dapat digunakan untuk mencari solusi awal berupa MST (Minimum Spanning Tree).
		

Jika terdapat lebih dari satu MST dengan biaya total sama, maka kita bisa memilih di antara MST tersebut dengan membandingkan total bobot keandalan.
		

Algoritma Dijkstra lebih cocok untuk menyelesaikan masalah ini karena mempertimbangkan bobot dan jalur terpendek.
		

Struktur data Disjoint Set Union (DSU) sangat berguna untuk mendeteksi siklus saat membangun MST menggunakan Kruskal.

Soal 5

Sebuah pusat distribusi di kota Metrix menggunakan sistem penataan otomatis untuk mengurutkan kontainer sebelum dikirim ke pelanggan. Setiap kontainer memiliki nomor unik dari 1 hingga n, dan seluruh kontainer awalnya tersusun dalam urutan acak di sepanjang lintasan conveyor.

Sistem hanya dapat melakukan pertukaran dua kontainer bersebelahan sekaligus dalam satu langkah. Tujuan sistem adalah menata ulang kontainer sehingga nomornya tersusun secara menaik, dari 1 sampai n, dengan jumlah pertukaran minimum.

Karena keterbatasan waktu proses, teknisi sistem ingin menghitung seberapa cepat sistem bisa menyelesaikan tugas tersebut, dan sedang mempertimbangkan berbagai pendekatan algoritmik serta analisis teoritis.
Benar 	Salah 	Pernyataan
		

Fenwick Tree dan Segment Tree bisa digunakan untuk menghitung jumlah inversion pada array
		

Jumlah minimum swap yang dilakukan sama dengan jumlah inversion pada array
		

Algoritma bubble sort yang dilakukan memiliki kompleksitas terburuk O(n log n)
		

Jumlah maksimal swap adalah n2

Soal 6

Sebuah perusahaan ekspedisi di kota Techvalley sedang mengembangkan sistem pengambilan keputusan otomatis untuk menentukan barang mana saja yang harus dimasukkan ke dalam satu kendaraan pengantar.

Terdapat n buah barang, masing-masing dengan berat dan nilai ekonomi. Setiap kendaraan memiliki kapasitas maksimum W (dalam satuan berat). Tujuan sistem adalah memilih kombinasi barang yang memaksimalkan nilai total tanpa melebihi kapasitas kendaraan.

Karena ribuan pengambilan keputusan ini harus dilakukan setiap jam, insinyur perusahaan ingin tahu apakah strategi greedy cukup baik, atau apakah harus menggunakan algoritma dinamis yang lebih kompleks.
Benar 	Salah 	Pernyataan
		

Penyelesaian terbaik untuk knapsack adalah DP 
		

Strategi greedy berdasarkan rasio nilai/berat selalu memberikan solusi optimal untuk Knapsack
		

Kompleksitas waktu dari solusi DP konvensional adalah O(nW)O(nW)O(nW), di mana n adalah jumlah barang dan W kapasitas maksimum.
		

Jika seluruh berat barang kelipatan bilangan tetap (misalnya 5), maka kita bisa melakukan kompresi state untuk menghemat memori dalam DP.

---

# Sesi 3

> [!info] Detail
> - **Tipe:** Pilihan ganda.
> - **Jumlah:** 10 soal.
> - **Waktu:** 60 menit.
> - **Penilaian:**
> 	- Benar: +1
> 	- Kosong: 0
> 	- Salah: 0
> - **Skor:** 10/15 (66.67%)

> [!important] Pernyataan untuk Nomor 1–3
> Perhatikan potongan kode berikut.
> 
> ```cpp
> long long air(long long api, long long panas) {
> 	if (api == 0 || panas == 0) {
> 		return 1;
> 	}
> 
> 	return air(api - 1, panas) + air(api, panas - 1);
> }
> ```

> [!question] Nomor 1
> Tentukan keluaran dari `air(3, 3)`.
> 
> - [x] ***20***
> - [ ] 6
> - [ ] 12
> - [ ] 30
> - [ ] 18

> [!question] Nomor 2
> Tentukan keluaran dari `air(6, 8)`.
> 
> - [ ] 1001
> - [ ] 2002
> - [x] ***3003***
> - [ ] 4004
> - [ ] 5005

> [!question] Nomor 3
> Tentukan keluaran dari `air(9, 5)`.
> 
> - [ ] 1001
> - [ ] *2002*
> - [ ] 3003
> - [ ] 4004
> - [x] **5005**

> [!question] Nomor 4
> Pak Dengklek sedang berlatih mengerjakan soal *binary search* klasik karena ia akan mengikuti OSN-P 2040. Berikut adalah program yang ia buat.
> 
> ```cpp
> #include <bits/stdc++.h>
> using namespace std;
> 
> int main()
> {
> 	int N;
> 	cin >> N;
> 
> 	int arr[N + 1];
> 	for (int i = 1; i <= N; i++)
> 		cin >> arr[i];
> 
> 	int cari;
> 	cin >> cari;
> 
> 	int kiri = 1;
> 	int kanan = N;
> 	
> 	bool ketemu = false;
> 
> 	while (kiri <= kanan) {
> 		int tengah = (kiri + kanan) / 2;
> 
> 		if (arr[tengah] == cari) {
> 			ketemu = true;
> 			break;
> 		} else if (arr[tengah] < cari) {
> 			kiri = tengah + 1;
> 		} else {
> 			kanan = tengah - 1;
> 		}
> 	}
> 
> 	if (ketemu == false)
> 		cout << "Tidak ada\n";
> 	else
> 		cout << "Ada\n"
> }
> ```
> 
> Namun program yang ia buat sering membuat kesalahan output. Program tersebut bisa mengoutput `Tidak ada` saat bilangan yang dicari sebenarnya ada dalam barisan tersebut. Baris apa yang seharusnya ditambahkan Pak Dengklek?
> 
> - [ ] `sort(arr, arr+N);`
> - [x] ***`sort(arr+1, arr+N+1);`***
> - [ ] `sort(arr, arr+N, greater<int>());`
> - [ ] `sort(arr+1, arr+N+1, greater<int>());`
> - [ ] Tidak ada yang perlu ditambah, tetapi ada baris yang kurang tepat

> [!question] Nomor 5
> Pak Dengklek sedang membuat program untuk mencari banyaknya pasangan $(i, j)$ dengan $0 \leq i < j < N$ di mana $A_i \times A_j = A_i \mathbin{\text{or}} A_j$. Berikut adalah perintah program yang ia buat.
> 
> ```cpp
> #include <bits/stdc++.h>
> using namespace std;
> 
> int main()
> {
> 	int N;
> 	cin >> N;
> 
> 	int A[N];
> 	for (int i = 0; i < N; i++)
> 		cin >> A[i];
> 
> 	long long ans = 0;
> 	for (int i = 0; i < N; i++) {
> 		for (int j = i + 1; j < N; j++) {
> 			if (A[i] * A[j] == A[i] | A[j]) {
> 				ans++;
> 			}
> 		}
> 	}
> 
> 	cout << ans << endl;
> 	return 0;
> }
> ```
> 
> Namun, ketika ia mencoba untuk menjalan program tersebut, ia mendapatkan hasil yang tidak sesuai dengan jawaban yang sesungguhnya. Bantu Pak Dengklek untuk menentukan pada baris keberapa Pak Dengklek perlu memperbaiki programnya!
> - [ ] 9
> - [ ] 10
> - [x] ***11***
> - [ ] 12
> - [ ] Tidak ada yang perlu diperbaiki